//! Instantiate a module, call functions, and read exports.

use crate::{
    capi_executor::{vm_exec_executor_t, CapiExecutor},
    service_singleton::with_service,
    string_copy, vm_exec_result_t,
};
use elrond_exec_service::{CompilationOptions, Instance};
use libc::{c_char, c_int};
use std::{ffi::CStr, slice};

/// Opaque pointer to a `wasmer_runtime::Instance` value in Rust.
///
/// A `wasmer_runtime::Instance` represents a WebAssembly instance. It
/// is generally generated by the `wasmer_instantiate()` function, or by
/// the `wasmer_module_instantiate()` function for the most common paths.
#[repr(C)]
pub struct vm_exec_instance_t;

/// Opaque pointer to a `wasmer_runtime::Ctx` value in Rust.
///
/// An instance context is passed to any host function (aka imported
/// function) as the first argument. It is necessary to read the
/// instance data or the memory, respectively with the
/// `wasmer_instance_context_data_get()` function, and the
/// `wasmer_instance_context_memory()` function.
///
/// It is also possible to get the instance context outside a host
/// function by using the `wasmer_instance_context_get()`
/// function. See also `wasmer_instance_context_data_set()` to set the
/// instance context data.
///
/// Example:
///
/// ```c
/// // A host function that prints data from the WebAssembly memory to
/// // the standard output.
/// void print(wasmer_instance_context_t *context, int32_t pointer, int32_t length) {
///     // Use `wasmer_instance_context` to get back the first instance memory.
///     const wasmer_memory_t *memory = wasmer_instance_context_memory(context, 0);
///
///     // Continueâ€¦
/// }
/// ```
// #[repr(C)]
// pub struct wasmer_instance_context_t;

#[repr(C)]
pub struct vm_exec_compilation_options_t;

pub struct CapiInstance {
    content: Box<dyn Instance>,
}

#[allow(clippy::cast_ptr_alignment)]
#[no_mangle]
pub unsafe extern "C" fn vm_exec_new_instance(
    executor_ptr: *mut vm_exec_executor_t,
    instance_ptr_ptr: *mut *mut vm_exec_instance_t,
    wasm_bytes_ptr: *mut u8,
    wasm_bytes_len: u32,
    options_ptr: *const vm_exec_compilation_options_t,
) -> vm_exec_result_t {
    let capi_executor = cast_input_ptr!(executor_ptr, CapiExecutor, "executor ptr is null");

    if wasm_bytes_ptr.is_null() {
        with_service(|service| service.update_last_error_str("wasm bytes ptr is null".to_string()));
        return vm_exec_result_t::VM_EXEC_ERROR;
    }

    let wasm_bytes: &[u8] = slice::from_raw_parts_mut(wasm_bytes_ptr, wasm_bytes_len as usize);
    let compilation_options: &CompilationOptions = &*(options_ptr as *const CompilationOptions);
    let instance_result = capi_executor
        .content
        .new_instance(wasm_bytes, compilation_options);
    // with_service(|service| service.new_instance());
    match instance_result {
        Ok(instance_box) => {
            let capi_instance = CapiInstance {
                content: instance_box,
            };
            *instance_ptr_ptr = Box::into_raw(Box::new(capi_instance)) as *mut vm_exec_instance_t;
            vm_exec_result_t::VM_EXEC_OK
        }
        Err(message) => {
            with_service(|service| service.update_last_error_str(message.to_string()));
            vm_exec_result_t::VM_EXEC_ERROR
        }
    }
}

/// Calls an exported function of a WebAssembly instance by `name`
/// with the provided parameters. The exported function results are
/// stored on the provided `results` pointer.
///
/// This function returns `vm_exec_result_t::WASMER_OK` upon success,
/// `vm_exec_result_t::WASMER_ERROR` otherwise. You can use
/// `wasmer_last_error_message()` to get the generated error message.
///
/// Potential errors are the following:
///
///   * `instance` is a null pointer,
///   * `name` is a null pointer,
///   * `params` is a null pointer.
#[allow(clippy::cast_ptr_alignment)]
#[no_mangle]
pub unsafe extern "C" fn vm_exec_instance_call(
    instance_ptr: *mut vm_exec_instance_t,
    func_name_ptr: *const c_char,
) -> vm_exec_result_t {
    let capi_instance = cast_input_ptr!(instance_ptr, CapiInstance, "instance ptr is null");

    // unpack the function name
    if func_name_ptr.is_null() {
        with_service(|service| service.update_last_error_str("name ptr is null".to_string()));
        return vm_exec_result_t::VM_EXEC_ERROR;
    }
    let func_name_c = CStr::from_ptr(func_name_ptr);
    let func_name_r = func_name_c.to_str().unwrap();

    let result = capi_instance.content.call(func_name_r);
    match result {
        Ok(()) => vm_exec_result_t::VM_EXEC_OK,
        Err(message) => {
            with_service(|service| service.update_last_error_str(message));
            vm_exec_result_t::VM_EXEC_ERROR
        }
    }
}

#[allow(clippy::cast_ptr_alignment)]
#[no_mangle]
pub unsafe extern "C" fn vm_check_signatures(
    _instance: *mut vm_exec_instance_t,
) -> vm_exec_result_t {
    vm_exec_result_t::VM_EXEC_OK
}

#[allow(clippy::cast_ptr_alignment)]
#[no_mangle]
pub unsafe extern "C" fn vm_exec_instance_has_function(
    instance_ptr: *mut vm_exec_instance_t,
    func_name_ptr: *const c_char,
) -> c_int {
    let capi_instance = cast_input_ptr!(instance_ptr, CapiInstance, "instance ptr is null", -1);

    // unpack the function name
    return_if_ptr_null!(func_name_ptr, "function name ptr is null", -1);
    let func_name_c = CStr::from_ptr(func_name_ptr);
    let func_name_r = func_name_c.to_str().unwrap();

    if capi_instance.content.has_function(func_name_r) {
        1
    } else {
        0
    }
}

#[allow(clippy::cast_ptr_alignment)]
#[no_mangle]
pub unsafe extern "C" fn vm_exported_function_names_length(
    instance_ptr: *mut vm_exec_instance_t,
) -> c_int {
    let capi_instance = cast_input_ptr!(instance_ptr, CapiInstance, "instance ptr is null", 0);

    let func_names = capi_instance.content.get_exported_function_names();
    if func_names.is_empty() {
        0
    } else {
        let len_sum: usize = func_names.iter().map(|func_name| func_name.len()).sum();
        (len_sum + func_names.len()) as c_int
    }
}

#[allow(clippy::cast_ptr_alignment)]
#[no_mangle]
pub unsafe extern "C" fn vm_exported_function_names(
    instance_ptr: *mut vm_exec_instance_t,
    dest_buffer: *mut c_char,
    dest_buffer_len: c_int,
) -> c_int {
    let capi_instance = cast_input_ptr!(instance_ptr, CapiInstance, "instance ptr is null", 0);

    let func_names = capi_instance.content.get_exported_function_names();
    let concat = func_names.join("|");
    string_copy(concat, dest_buffer, dest_buffer_len)
}

// /// Gets the `memory_idx`th memory of the instance.
// ///
// /// Note that the index is always `0` until multiple memories are supported.
// ///
// /// This function is mostly used inside host functions (aka imported
// /// functions) to read the instance memory.
// ///
// /// Example of a _host function_ that reads and prints a string based on a pointer and a length:
// ///
// /// ```c
// /// void print_string(const wasmer_instance_context_t *context, int32_t pointer, int32_t length) {
// ///     // Get the 0th memory.
// ///     const wasmer_memory_t *memory = wasmer_instance_context_memory(context, 0);
// ///
// ///     // Get the memory data as a pointer.
// ///     uint8_t *memory_bytes = wasmer_memory_data(memory);
// ///
// ///     // Print what we assumed to be a string!
// ///     printf("%.*s", length, memory_bytes + pointer);
// /// }
// /// ```
// // #[allow(clippy::cast_ptr_alignment)]
// // #[no_mangle]
// // pub extern "C" fn wasmer_instance_context_memory(
// //     ctx: *const wasmer_instance_context_t,
// //     _memory_idx: u32,
// // ) -> *const wasmer_memory_t {
// //     let ctx = unsafe { &*(ctx as *const Ctx) };
// //     let memory = ctx.memory(0);
// //     memory as *const Memory as *const wasmer_memory_t
// // }

/// Frees memory for the given `vm_exec_instance_t`.
///
/// Check the `wasmer_instantiate()` function to get a complete
/// example.
///
/// If `instance` is a null pointer, this function does nothing.
///
/// Example:
///
/// ```c
/// // Get an instance.
/// vm_exec_instance_t *instance = NULL;
/// wasmer_instantiate(&instance, bytes, bytes_length, imports, 0);
///
/// // Destroy the instance.
/// wasmer_instance_destroy(instance);
/// ```
#[allow(clippy::cast_ptr_alignment)]
#[no_mangle]
pub extern "C" fn vm_exec_instance_destroy(instance: *mut vm_exec_instance_t) {
    if !instance.is_null() {
        unsafe {
            std::ptr::drop_in_place(instance);
        }
        // unsafe { Box::from_raw(instance as *mut Instance) };
    }
}
